# Reference

<!-- DO NOT EDIT: This document was generated by Puppet Strings -->

## Table of Contents

### Functions

* [`pty::spawn`](#pty--spawn): Spawns the specified command on a newly allocated pty.

### Data types

* [`PTY::IO`](#PTY--IO): The PTY::IO object represents an IO-object to communicate via the PTY. This object is created by the `pty::spawn()` function and passed to th

## Functions

### <a name="pty--spawn"></a>`pty::spawn`

Type: Ruby 4.x API

This function is designed to be used in a Bolt plan. See PTY::IO
DataType documentation for more details.

**Note:** Not available in apply block.

#### Examples

##### Spawn /bin/sh and get the hostname

```puppet
pty::spawn(['/bin/sh', '--norc']) |$pty| {
  $pty.puts('export PS1="pty::io$ "')
  $pty.read()
  $pty.set_expected_prompt(/\Rpty::io\$ /)
  $hostname = $pty.pwp('hostname').strip()
}
```

#### `pty::spawn(Array[String[1]] $cmd, Callable[PTY::IO] &$block)`

This function is designed to be used in a Bolt plan. See PTY::IO
DataType documentation for more details.

**Note:** Not available in apply block.

Returns: `Undef`

##### Examples

###### Spawn /bin/sh and get the hostname

```puppet
pty::spawn(['/bin/sh', '--norc']) |$pty| {
  $pty.puts('export PS1="pty::io$ "')
  $pty.read()
  $pty.set_expected_prompt(/\Rpty::io\$ /)
  $hostname = $pty.pwp('hostname').strip()
}
```

##### `cmd`

Data type: `Array[String[1]]`

The command to spawn

##### `&block`

Data type: `Callable[PTY::IO]`

The code block, that is using PTY::IO object yielded to talk to the command executed

## Data types

### <a name="PTY--IO"></a>`PTY::IO`

The PTY::IO object represents an IO-object to communicate via the PTY. This
object is created by the `pty::spawn()` function and passed to the block
yielded. It's not expected to be created manually.

#### Functions

The following functions are available in the `PTY::IO` data type.

### <a name="write"></a>`write`

#### `PTY::IO.write(param1)`

Send a message as-is

Returns: `Integer`

##### `param1`

Data type: `String[1]`



### <a name="puts"></a>`puts`

#### `PTY::IO.puts(param1)`

Send a message with terminating line feed appended

Returns: `Undef`

##### `param1`

Data type: `String`



### <a name="read"></a>`read`

#### `PTY::IO.read(param1)`

Read the input if any

Returns: `Variant[String, Undef]`

##### `param1`

Data type: `Struct[{'maxlen' => Optional[Integer[0]], 'timeout' => Optional[Variant[Integer[0], Float]]}]`



### <a name="set_expected_prompt"></a>`set_expected_prompt`

#### `PTY::IO.set_expected_prompt(param1)`

Set the prompt to implicitly expect by `pwp()` and `pwp_until()` methods

Returns: `Regexp`

##### `param1`

Data type: `Variant[Regexp, String]`



### <a name="expect"></a>`expect`

#### `PTY::IO.expect(param1, param2)`

Wait for a pattern to appear (or until timeout expires)

Returns: `Variant[String, Undef]`

##### `param1`

Data type: `Variant[Regexp, String[1]]`



##### `param2`

Data type: `Struct[{'timeout' => Optional[Variant[Integer, Float]]}]`



### <a name="pwp"></a>`pwp`

#### `PTY::IO.pwp(param1, param2)`

Send a message, wait for the prompt and return the text received

Returns: `Variant[String, Undef]`

##### `param1`

Data type: `String[1]`



##### `param2`

Data type: `Struct[{'timeout' => Optional[Variant[Integer, Float]], 'keep_prompt' => Optional[Boolean]}]`



### <a name="pwp_until"></a>`pwp_until`

#### `PTY::IO.pwp_until(param1, param2, param3)`

Send the message, wait for the prompt, check for the pattern, repeat if not found

Returns: `Variant[String, Undef]`

##### `param1`

Data type: `String[1]`



##### `param2`

Data type: `Regexp`



##### `param3`

Data type: `Struct[{'interval' => Optional[Variant[Integer[0], Float]], 'limit' => Optional[Integer[0]], 'timeout' => Optional[Variant[Integer[0], Float]]}]`



### <a name="type_in"></a>`type_in`

#### `PTY::IO.type_in(param1)`

Send a message by typing a char and waiting for it to be echoed back by console before typing a next one

Returns: `Variant[String, Undef]`

##### `param1`

Data type: `String[1]`



### <a name="set_raw"></a>`set_raw`

#### `PTY::IO.set_raw`

Switch the pty to raw mode

Returns: `Undef`

### <a name="set_cooked"></a>`set_cooked`

#### `PTY::IO.set_cooked`

Switch the pty to 'cooked' mode (default mode usually)

Returns: `Undef`

### <a name="set_echo"></a>`set_echo`

#### `PTY::IO.set_echo(param1)`

Enable/disable echo on the pty

Returns: `Boolean`

##### `param1`

Data type: `Boolean`



### <a name="set_debug"></a>`set_debug`

#### `PTY::IO.set_debug(param1)`

Enable/disable debug messages on stderr

Returns: `Boolean`

##### `param1`

Data type: `Boolean`



